// / <Reference path="./monaco-editor/monaco.d.ts" />
// / <Reference path="./typescript/lib/typescriptServices.d.ts" />
// / <Reference path="../../../../@types/jquery/index.d.ts" />
// / <Reference path="../../../../@types/requirejs/index.d.ts" />

//var require: Require;
require && require.config({ paths: { 'vs': 'vendor/monaco-editor/min/vs' } });

namespace ts {
    export interface IMonacoTypeScriptServiceProxy {
        _getModel(uri: string): Promise<{ _eol: string, _lineStarts: any, _Lines: string[], length: number, _uri: monaco.Uri, _versionId: number }>;
        getCompilationSettings(): Promise<CompilerOptions>;
        getCompilerOptionsDiagnostics(): Promise<Diagnostic[]>;
        getCompletionEntryDetails(uri: string, position: number, name: string, formatOptions: FormatCodeOptions | FormatCodeSettings | undefined, source: string | undefined, preferences: UserPreferences | undefined): Promise<CompletionEntryDetails | undefined>;
        getCompletionsAtPosition(uri: string, position: number, options: GetCompletionsAtPositionOptions | undefined): Promise<WithMetadata<CompletionInfo> | undefined>;
        getCurrentDirectory(): Promise<string>;
        getDefaultLibFileName(options: CompilerOptions): Promise<string>;
        getDefinitionAtPosition(uri: string, position: number): Promise<ReadonlyArray<DefinitionInfo> | undefined>;
        getEmitOutput(uri: string, emitOnlyDtsFiles?: boolean): Promise<EmitOutput>;
        getFormattingEditsAfterKeystroke(uri: string, position: number, key: string, options: FormatCodeOptions | FormatCodeSettings): Promise<TextChange[]>;
        getFormattingEditsForDocument(uri: string, options: FormatCodeOptions | FormatCodeSettings): Promise<TextChange[]>;
        getFormattingEditsForRange(uri: string, start: number, end: number, options: FormatCodeOptions | FormatCodeSettings): Promise<TextChange[]>;
        getNavigationBarItems(uri: string): Promise<NavigationBarItem[]>;
        getOccurrencesAtPosition(uri: string, position: number): Promise<ReadonlyArray<ReferenceEntry> | undefined>;
        getQuickInfoAtPosition(uri: string, position: number): Promise<QuickInfo | undefined>;
        getReferencesAtPosition(uri: string, position: number): Promise<ReferenceEntry[] | undefined>;
        getScriptFileNames(): Promise<string[]>;
        getScriptKind(uri: string): Promise<ScriptKind>;
        getScriptSnapshot(uri: string): Promise<IScriptSnapshot | undefined>;
        getScriptVersion(uri: string): Promise<string>;
        /** The first time this is called, it will return global diagnostics (no location). */
        getSemanticDiagnostics(uri: string): Promise<Diagnostic[]>;
        getSignatureHelpItems(uri: string, position: number, options: SignatureHelpItemsOptions | undefined): Promise<SignatureHelpItems | undefined>;
        getSyntacticDiagnostics(uri: string): Promise<DiagnosticWithLocation[]>;
        isDefaultLibFileName(uri: string): Promise<boolean>;
    }
}

// A wrapper for the ACE editor for use with editing code on the UI.

namespace Monaco {

    export interface OnReady { (editor: MonacoEditor, currentCode: string): string };
    export interface OutputHandler { (editor: MonacoEditor, tsCode:string, compiledCode: string): void };

    export var activeEditor: monaco.editor.IStandaloneCodeEditor;

    export class MonacoEditor {
        private _editor: monaco.editor.IStandaloneCodeEditor;
        // private _outputEditor: monaco.editor.IStandaloneCodeEditor;
        private _tsServiceProxy: ts.IMonacoTypeScriptServiceProxy;

        __tsProxy: ts.IMonacoTypeScriptServiceProxy;

        target: HTMLElement;

        /** An optional handler to execute when ready to set the initial code for the TS editor. */
        onReady: OnReady;

        /** The target element to render the editor in for the compiled JS (usually a DIV block). */
        outputTarget: OutputHandler;

        initialCode: string;

        constructor(target: string | HTMLElement, outputTarget?: OutputHandler, onReady?: OnReady, initialCode?: string) {
            if (!target) throw "new MonacoEditor(target, outputTarget): 'target' is required (string or element value)."
            if (!outputTarget) throw "new MonacoEditor(target, outputTarget): 'outputTarget' handler is required."
            if (typeof outputTarget != 'function') throw "new MonacoEditor(target, outputTarget): 'outputTarget' is not a function."
            if (onReady && typeof onReady != 'function') throw "new MonacoEditor(target, outputTarget): 'onReady' is not a function."
            this.target = target instanceof HTMLElement ? target : document.getElementById(target);
            if (!(this.target instanceof HTMLElement)) throw "new MonacoEditor(target, outputTarget): 'target' is invalid."
            this.outputTarget = outputTarget;
            this.onReady = onReady;
            this.initialCode = initialCode && ''+initialCode || '';
        }

        async initialize() {
            if (!require)
                throw "'RequireJS' is not loaded.";

            //if (!ts)
            //    throw "'ts' TypeScript service namespace reference is required - is the 'ace/mode/typescript/typescriptServices.js' file loaded?.";

            console.log("initialize(): Creating the Monaco editor promise ...");

            return new Promise<any>((resolve, reject) => {
                console.log("initialize(): Loading the Monaco editor ...");

                require(['vs/editor/editor.main'], (main: typeof monaco) => {

                    if (!main) {
                        var msg = "initialize(): Failed loading 'vs/editor/editor.main'. Make sure 'node_modules\\monaco-editor' exists, as the project will copy it to 'wwwroot\\js'.";
                        (console.error || console.log)(msg);
                        throw msg;
                        return;
                    }

                    console.log("initialize(): Creating the Monaco editor ...");

                    main.languages.typescript.typescriptDefaults.addExtraLib("var ctx: { x: string, y: string };");

                    // ... load the editors ...

                    activeEditor = this._editor = main.editor.create(this.target, {
                        automaticLayout: true, // (https://stackoverflow.com/questions/47017753/monaco-editor-dynamically-resizable)
                        value: this.initialCode || '', //[''].join('\n'),
                        language: 'typescript'
                    });

                    // this._outputEditor = main.editor.create(this.outputTarget, {
                    //     automaticLayout: true,
                    //     readOnly: true,
                    //     codeLens: false,
                    //     contextmenu: false,
                    //     value: [
                    //         '// Output JS does here ...'
                    //     ].join('\n'),
                    //     language: 'javascript'
                    // });

                    var sync = () => {
                        if (this._tsServiceProxy)
                            setTimeout(() => {
                                this._tsServiceProxy.getEmitOutput(this._editor.getModel().uri.toString())
                                    .then((r) => {
                                        this.outputTarget(this, this._editor.getValue(), r.outputFiles[0].text);
                                        // console.log("Code updated: " + r.outputFiles[0].text);
                                    });
                            }, 500);
                    };

                    this._editor.onDidChangeModelContent(sync);

                    console.log("initialize(): Monaco editors created. Getting the TS worker ...");

                    // ... get the typescript service ...

                    monaco.languages.typescript.getTypeScriptWorker().then((workerProxy: (v: monaco.Uri) => Promise<ts.IMonacoTypeScriptServiceProxy>) => {
                        console.log("initialize(): Got the TS worker proxy. Getting the service next ...");
                        var fileUri = this._editor.getModel().uri;
                        workerProxy(fileUri).then((tsProxy) => {
                            console.log("initialize(): Got the TS worker service proxy:");
                            console.log(tsProxy);
                            this.__tsProxy = tsProxy;
                            this._tsServiceProxy = tsProxy;
                            this._tsServiceProxy.getEmitOutput(fileUri.toString()).then((r: any) => {
                                // ... execute any "ready" callbacks ...
                                // this._outputEditor.setValue(r.outputFiles[0].text);
                                this._editor.setValue(this.onReady(this, this._editor.getValue()));
                                resolve(this);
                            });
                        });
                    }, (reason) => { reject("Error getting TypeScript service worker: " + reason); });

                }, (msg: RequireError) => {
                    console.log("initialize(): Failed loading the Monaco editor");
                    reject("Failed loading 'FlowScript/ace/ace_ts_editor_main' module: " + msg + "\r\n" + ((<any>msg).stack || ""));
                });
            });
        }

        /**
         * Loads an array of library files by URL.
         */
        loadLibFiles(libFiles: string[]): void { monaco.languages.typescript.typescriptDefaults.addExtraLib("class ctx { x:0; }"); }
        loadFile(filename: string): void { /*this._tsService.loadFile(filename);*/ }
        setCode(text: string): void { /*this._tsService.setCode(text); */ }
        setOutput(text: string): void { /*this._tsService.setOutput(text);*/ }
        getCode(): string { return null; /*this._tsService.getCode();*/ }
        getOutput(): string { return null; /*this._tsService.getOutput();*/ }
    }
}